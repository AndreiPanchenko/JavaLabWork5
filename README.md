# Лабораторная работа №5

## Формулировки задач

### Задание 1.1. Шаблоны
В класс Дробь добавить интерфейс на два метода: получение вещественного значения, установка числителя и установка знаменателя. Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного значения.

### Задание 2.1. Структурные шаблоны
Количество мяуканий. Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих. Необходимо таким образом передать кота в указанный метод, чтобы после окончания его работы узнать сколько раз мяукал кот за время его работы.

### Задание 3.3. Список
Даны упорядоченные списки L1 и L2. Вставить элементы списка L2 в список L1, не нарушая его упорядоченности.

### Задание 4.3. Мап
На вход программы подаются сведения о результатах соревнований по школьному многоборью. Необходимо вывести фамилии и имена трех лучших участников многоборья.

### Задание 5.7. Сет
Файл содержит текст на русском языке. Сколько разных букв встречается в тексте?

### Задание 6.2. Очередь
По списку L построить очередь (например, по списку из элементов 1, 2, 3 требуется построить очередь из элементов 1, 2, 3, 3, 2, 1).

### Задание 7.1. Стрим
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это все в ломаную.

### Задание 7.2. Стрим
Дан текстовый файл со строками, содержащими имя человека и его номер. Необходимо написать стрим выполняющую группировку имен по номерам.

## Структура проекта

```
src/
├── main/
│   ├── Main.java
│   └── InputChecker.java
├── fraction/ (Задание 1.1)
│   ├── FractionTask.java
│   ├── Fraction.java
│   └── FractionInterface.java
├── cat/ (Задание 2.1)
│   ├── CatTask.java
│   ├── Cat.java
│   ├── Funs.java
│   ├── CountingCat.java
│   └── Meowable.java
├── list/ (Задание 3.3)
│   └── ListTask.java
├── competition/ (Задание 4.3)
│   ├── CompetitionTask.java
│   └── StudentResult.java
├── letters/ (Задание 5.7)
│   └── LettersTask.java
├── queue/ (Задание 6.2)
│   └── QueueTask.java
├── point/ (Задание 7.1)
│   ├── PointTask.java
│   ├── Point.java
│   ├── Line.java
│   └── Polyline.java
└── name/ (Задание 7.2)
    └── NameTask.java
```

## Описание заданий и фрагменты кода

### Задание 1.1. Дроби с кэшированием (Шаблон Proxy)

**Использованные подходы:**
- Шаблон Proxy для кэширования вычислений
- Интерфейс для абстракции работы с дробями
- Автоматическая обработка отрицательных знаменателей

**Ключевой код:**

```java
public class Fraction implements FractionInterface {
    private int numerator;
    private int denominator;
    private Double cachedValue; // Кэш для десятичного значения

    @Override
    public double getDecimalValue() {
        if (cachedValue == null) {
            cachedValue = (double) numerator / denominator;
            System.out.println("Вычислено новое значение: " + cachedValue);
        } else {
            System.out.println("Использовано кэшированное значение: " + cachedValue);
        }
        return cachedValue;
    }

    @Override
    public void setDenominator(int denominator) {
        if (denominator == 0) {
            throw new IllegalArgumentException("Знаменатель не может быть нулем");
        }
        // Обработка отрицательных знаменателей
        if (denominator < 0) {
            this.numerator = -numerator;
            this.denominator = -denominator;
        } else {
            this.denominator = denominator;
        }
        this.cachedValue = null; // Сброс кэша при изменении
    }
}
```

**Комментарии:**
- Кэширование позволяет избежать повторных вычислений
- Автоматическая обработка отрицательных знаменателей обеспечивает корректное представление дроби
- Сброс кэша при изменении числителя или знаменателя гарантирует актуальность данных

### Задание 2.1. Подсчет мяуканий (Шаблон Decorator)

**Использованные подходы:**
- Шаблон Decorator для добавления функциональности без изменения исходного класса
- Работа через интерфейс для обеспечения полиморфизма

**Ключевой код:**

```java
public class CountingCat implements Meowable {
    private Cat cat;
    private int meowCount;

    @Override
    public void meow() {
        cat.meow();      // Делегирование вызова оригинальному коту
        meowCount++;     // Подсчет мяуканий
    }
}

public class Funs {
    public static void meowsCare(Meowable meowable) {
        for (int i = 0; i < 5; i++) {
            meowable.meow(); // Вызов мяуканья 5 раз
        }
    }
}
```

**Комментарии:**
- Decorator позволяет добавить подсчет мяуканий без изменения исходного класса Cat
- Работа через интерфейс Meowable обеспечивает гибкость и расширяемость

### Задание 3.3. Вставка упорядоченных списков

**Использованные подходы:**
- Использование Collections API для работы со списками
- Автоматическая сортировка для обеспечения упорядоченности

**Ключевой код:**

```java
private List<Integer> mergeSortedLists(List<Integer> list1, List<Integer> list2) {
    List<Integer> result = new ArrayList<>(list1);
    result.addAll(list2);      // Объединение списков
    Collections.sort(result);  // Сортировка результата
    return result;
}
```

**Комментарии:**
- Простое объединение с последующей сортировкой обеспечивает требуемую функциональность
- Использование стандартных методов Collections упрощает код

### Задание 4.3. Результаты соревнований (Map)

**Использованные подходы:**
- TreeMap с обратным порядком для автоматической сортировки результатов
- Валидация входных данных
- Обработка файлового и ручного ввода

**Ключевой код:**

```java
Map<Integer, List<StudentResult>> resultsByScore = new TreeMap<>(Collections.reverseOrder());

// Группировка по сумме баллов
for (StudentResult result : results) {
    int totalScore = result.getTotalScore();
    if (!resultsByScore.containsKey(totalScore)) {
        resultsByScore.put(totalScore, new ArrayList<>());
    }
    resultsByScore.get(totalScore).add(result);
}
```

**Комментарии:**
- TreeMap с обратным порядком автоматически сортирует результаты по убыванию
- Группировка по баллам упрощает вывод лучших участников

### Задание 5.7. Подсчет уникальных букв (Set)

**Использованные подходы:**
- HashSet для хранения уникальных символов
- Фильтрация только буквенных символов
- Отдельный подсчет кириллических букв

**Ключевой код:**

```java
Set<Character> uniqueLetters = new HashSet<>();
Set<Character> uniqueCyrillicLetters = new HashSet<>();

for (char c : text.toCharArray()) {
    if (Character.isLetter(c)) {
        uniqueLetters.add(Character.toLowerCase(c));
        if (isCyrillic(c)) {
            uniqueCyrillicLetters.add(Character.toLowerCase(c));
        }
    }
}
```

**Комментарии:**
- HashSet автоматически обеспечивает уникальность элементов
- Дополнительная проверка на кириллические символы расширяет функциональность

### Задание 6.2. Построение очереди

**Использованные подходы:**
- Интерфейс Queue и реализация LinkedList
- Простой алгоритм построения очереди

**Ключевой код:**

```java
private Queue<Integer> buildQueue(List<Integer> list) {
    Queue<Integer> queue = new LinkedList<>();
    
    // Добавление в прямом порядке
    for (Integer item : list) {
        queue.offer(item);
    }
    
    // Добавление в обратном порядке
    List<Integer> reversed = new ArrayList<>(list);
    Collections.reverse(reversed);
    for (Integer item : reversed) {
        queue.offer(item);
    }
    
    return queue;
}
```

**Комментарии:**
- Простой и эффективный алгоритм построения требуемой очереди
- Использование offer() для добавления элементов в очередь

### Задание 7.1. Обработка точек и ломаной (Stream API)

**Использованные подходы:**
- Stream API для обработки коллекций
- Функциональные операции: map, filter, distinct, sorted

**Ключевой код:**

```java
List<Point> processed = points.stream()
    .map(p -> new Point(p.getX(), Math.abs(p.getY()))) // Делаем Y положительными
    .distinct()                                        // Убираем дубликаты
    .sorted(Comparator.comparingDouble(Point::getX))   // Сортируем по X
    .collect(Collectors.toList());                     // Собираем в список
```

**Комментарии:**
- Цепочка операций Stream API обеспечивает декларативный стиль программирования
- Каждая операция выполняет конкретное преобразование данных

### Задание 7.2. Обработка файла с именами (Stream API)

**Использованные подходы:**
- Stream API для обработки файла
- Группировка данных с помощью Collectors.groupingBy
- Обработка и нормализация имен

**Ключевой код:**

```java
return reader.lines()
    .map(line -> line.split(":"))                    // Разделяем по двоеточию
    .filter(parts -> parts.length == 2)             // Фильтруем корректные строки
    .map(parts -> new String[]{capitalize(parts[0].trim()), parts[1].trim()})
    .filter(parts -> !parts[1].isEmpty())           // Убираем людей без номеров
    .collect(Collectors.groupingBy(
        parts -> Integer.parseInt(parts[1]),        // Группируем по номеру
        Collectors.mapping(parts -> parts[0], Collectors.toList())
    ));
```

**Комментарии:**
- Stream API позволяет эффективно обрабатывать файлы построчно
- Группировка по номеру с сохранением списка имен решает поставленную задачу

# Тестирование лабораторной работы №5

## Общие сведения о тестировании

Тестирование проводилось на компьютере со следующими характеристиками:
- **ОС**: Windows 11
- **Java**: OpenJDK 17
- **Память**: 8GB RAM
- **Процессор**: Intel Core i5

## Подробное тестирование каждого задания

### Задание 1.1. Дроби с кэшированием (Шаблон Proxy)

#### Тест 1: Создание и базовые операции

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить создание дроби и базовые операции |
| **Входные данные** | Числитель: 3, Знаменатель: 4 |
| **Ожидаемый результат** | Дробь 3/4, десятичное значение 0.75 |

**Результат выполнения:**
```
=== Задание 1.1: Дроби с кэшированием (Шаблон Proxy) ===
--- Создание дроби ---
Введите числитель: 3
Введите знаменатель: 4
Создана дробь: 3/4
--- Демонстрация кэширования ---
Первое вычисление десятичного значения:
Вычислено новое значение: 0.75
Результат: 0.75

Второе вычисление (должен использоваться кэш):
Использовано кэшированное значение: 0.75
Результат: 0.75
```

#### Тест 2: Обработка отрицательных значений

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить обработку отрицательных знаменателей |
| **Входные данные** | Числитель: 3, Знаменатель: -4 |
| **Ожидаемый результат** | Дробь -3/4, десятичное значение -0.75 |

**Результат выполнения:**
```
--- Работа с отрицательными значениями ---
Создадим дробь с отрицательным знаменателем:
Дробь с отрицательным знаменателем: -3/4
Десятичное значение: -0.75
```

#### Тест 3: Сравнение дробей

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить корректность сравнения дробей |
| **Входные данные** | Дроби: 3/4 и 6/8 |
| **Ожидаемый результат** | Дроби не равны (разные числитель и знаменатель) |

**Результат выполнения:**
```
--- Сравнение дробей ---
Дробь 1: 3/4
Дробь 2: 6/8
Дроби равны: false
```

### Задание 2.1. Подсчет мяуканий (Шаблон Decorator)

#### Тест 1: Базовый подсчет мяуканий

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить подсчет мяуканий через декоратор |
| **Входные данные** | Имя кота: "Барсик" |
| **Ожидаемый результат** | 5 мяуканий после вызова Funs.meowsCare() |

**Результат выполнения:**
```
=== Задание 2.1: Подсчет мяуканий (Шаблон Decorator) ===
Введите имя кота: Барсик
--- Точное соответствие примеру из задания ---
Создан: кот: Барсик (мяукнул: 0 раз)
Количество мяуканий до вызова: 0
Барсик: мяу!
Барсик: мяу!
Барсик: мяу!
Барсик: мяу!
Барсик: мяу!
Результат: кот мяукал 5 раз
```

#### Тест 2: Дополнительные мяукания

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить накопление счетчика при дополнительных вызовах |
| **Входные данные** | Два дополнительных вызова meow() |
| **Ожидаемый результат** | Общее количество мяуканий: 7 |

**Результат выполнения:**
```
--- Дополнительная демонстрация ---
Вызываем еще несколько мяуканий:
Барсик: мяу!
Барсик: мяу!
Общее количество мяуканий: 7
Финальное состояние: кот: Барсик (мяукнул: 7 раз)
```

### Задание 3.3. Вставка упорядоченных списков

#### Тест 1: Объединение двух списков

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить объединение упорядоченных списков |
| **Входные данные** | L1: [1, 3, 5], L2: [2, 4, 6] |
| **Ожидаемый результат** | [1, 2, 3, 4, 5, 6] |

**Результат выполнения:**
```
=== Задание 3.3: Вставка упорядоченных списков ===
--- Заполнение списка L1 ---
Введите количество элементов в L1: 3
Введите элементы списка L1:
Элемент 1: 1
Элемент 2: 3
Элемент 3: 5
--- Заполнение списка L2 ---
Введите количество элементов в L2: 3
Введите элементы списка L2:
Элемент 1: 2
Элемент 2: 4
Элемент 3: 6
Исходные данные:
L1 (отсортирован): [1, 3, 5]
L2 (отсортирован): [2, 4, 6]
Результат после вставки:
Объединенный список: [1, 2, 3, 4, 5, 6]
```

#### Тест 2: Случай с пустым списком

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить обработку пустого списка |
| **Входные данные** | L1: [1, 2], L2: [] |
| **Ожидаемый результат** | [1, 2] |

**Результат выполнения:**
```
L1 (отсортирован): [1, 2]
L2 (отсортирован): []
Результат после вставки:
Объединенный список: [1, 2]
```

### Задание 4.3. Результаты соревнований (Map)

#### Тест 1: Обработка данных из файла

**Файл competitions.txt:**
```
Иванова Мария 5 8 6 3
Петров Сергей 9 9 5 7
Сидорова Анна 8 7 9 6
Козлов Дмитрий 7 6 8 9
Николаева Ольга 9 9 9 9
```

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить определение лучших участников |
| **Входные данные** | Файл с 5 участниками |
| **Ожидаемый результат** | Вывод трех лучших с учетом одинаковых баллов |

**Результат выполнения:**
```
=== Задание 4.3: Результаты соревнований (Map) ===
1 - Использовать готовый файл competitions.txt
2 - Ввести данные вручную
Выберите вариант: 1
Прочитано 5 корректных записей из файла.
=== РЕЗУЛЬТАТЫ СОРЕВНОВАНИЙ ===
--- 1 место ---
Николаева Ольга - 36 баллов (баллы: [9, 9, 9, 9])
--- 2 место ---
Петров Сергей - 30 баллов (баллы: [9, 9, 5, 7])
Сидорова Анна - 30 баллов (баллы: [8, 7, 9, 6])
Козлов Дмитрий - 30 баллов (баллы: [7, 6, 8, 9])
```

#### Тест 2: Ручной ввод данных

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить ручной ввод и валидацию |
| **Входные данные** | 1 участник: Фамилия "Иванов", Имя "Алексей", баллы [8,7,9,6] |
| **Ожидаемый результат** | Корректная обработка и вывод |

**Результат выполнения:**
```
Введите количество учеников (1-100): 1
--- Ученик 1 ---
Фамилия: Иванов
Имя: Алексей
Введите баллы по 4 видам спорта (0-10):
Вид 1: 8
Вид 2: 7
Вид 3: 9
Вид 4: 6
=== РЕЗУЛЬТАТЫ СОРЕВНОВАНИЙ ===
--- 1 место ---
Иванов Алексей - 30 баллов (баллы: [8, 7, 9, 6])
```

### Задание 5.7. Подсчет уникальных букв (Set)

#### Тест 1: Анализ текста из файла

**Файл text.txt:**
```
Шаблоны проектирования - это проверенные решения распространенных проблем в программировании.
```

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить подсчет уникальных букв |
| **Входные данные** | Текст на русском языке |
| **Ожидаемый результат** | Подсчет уникальных букв и кириллических символов |

**Результат выполнения:**
```
=== Задание 5.7: Подсчет уникальных букв (Set) ===
1 - Использовать готовый файл text.txt
2 - Ввести текст вручную
Выберите вариант: 1
Текст прочитан из файла.
=== РЕЗУЛЬТАТЫ АНАЛИЗА ===
Общее количество уникальных букв: 20
Количество уникальных кириллических букв: 20
Уникальные кириллические буквы: [а, б, в, г, д, е, и, й, к, л, м, н, о, п, р, с, т, у, ч, щ]
Все уникальные буквы: [а, б, в, г, д, е, и, й, к, л, м, н, о, п, р, с, т, у, ч, щ]
```

#### Тест 2: Ручной ввод текста

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить обработку ручного ввода |
| **Входные данные** | "Hello World" |
| **Ожидаемый результат** | 7 уникальных букв (латиница) |

**Результат выполнения:**
```
Введите текст: Hello World
=== РЕЗУЛЬТАТЫ АНАЛИЗА ===
Общее количество уникальных букв: 7
Количество уникальных кириллических букв: 0
Уникальные кириллические буквы: []
Все уникальные буквы: [d, e, h, l, o, r, w]
```

### Задание 6.2. Построение очереди

#### Тест 1: Построение очереди по алгоритму

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить построение очереди |
| **Входные данные** | Список [1, 2, 3] |
| **Ожидаемый результат** | Очередь [1, 2, 3, 3, 2, 1] |

**Результат выполнения:**
```
=== Задание 6.2: Построение очереди ===
Введите количество элементов в списке: 3
Введите элементы списка:
Элемент 1: 1
Элемент 2: 2
Элемент 3: 3
Исходный список: [1, 2, 3]
Построенная очередь: [1, 2, 3, 3, 2, 1]
```

#### Тест 2: Очередь с одним элементом

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить граничный случай |
| **Входные данные** | Список [5] |
| **Ожидаемый результат** | Очередь [5, 5] |

**Результат выполнения:**
```
Исходный список: [5]
Построенная очередь: [5, 5]
```

### Задание 7.1. Обработка точек и ломаной (Stream API)

#### Тест 1: Обработка набора точек

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить преобразование точек в ломаную |
| **Входные данные** | Точки: (1,-2), (3,4), (1,2), (2,5), (3,4) |
| **Ожидаемый результат** | Ломаная с точками: {1;2}, {2;5}, {3;4} |

**Результат выполнения:**
```
=== Задание 7.1: Обработка точек и ломаной (Stream API) ===
Введите количество точек: 5
Введите координаты точек:
--- Точка 1 ---
X: 1
Y: -2
--- Точка 2 ---
X: 3
Y: 4
--- Точка 3 ---
X: 1
Y: 2
--- Точка 4 ---
X: 2
Y: 5
--- Точка 5 ---
X: 3
Y: 4
Исходные точки: [{1.0;-2.0}, {3.0;4.0}, {1.0;2.0}, {2.0;5.0}, {3.0;4.0}]
Результирующая ломаная: Ломаная линия [{1.0;2.0}, {2.0;5.0}, {3.0;4.0}]
--- Линии ломаной ---
Линия от {1.0;2.0} до {2.0;5.0}
Линия от {2.0;5.0} до {3.0;4.0}
```

### Задание 7.2. Обработка файла с именами (Stream API)

#### Тест 1: Группировка имен по номерам

**Файл names.txt:**
```
Вася:5
Петя:3
Аня:5
Оля:
Коля:3
```

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить группировку имен по номерам |
| **Входные данные** | Файл с именами и номерами |
| **Ожидаемый результат** | {5=[Вася, Аня], 3=[Петя, Коля]} |

**Результат выполнения:**
```
=== Задание 7.2: Обработка файла с именами (Stream API) ===
1 - Использовать готовый файл names.txt
2 - Ввести данные вручную
Выберите вариант: 1
=== РЕЗУЛЬТАТ ГРУППИРОВКИ ===
Сырой вывод: {3=[Петя, Коля], 5=[Вася, Аня]}
--- Форматированный вывод ---
Номер 3: [Петя, Коля]
Номер 5: [Вася, Аня]
--- Статистика ---
Всего номеров: 2
Всего людей: 4
```

#### Тест 2: Ручной ввод данных

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить ручной ввод и нормализацию имен |
| **Входные данные** | 3 записи: "вася:5", "ПЕТЯ:3", "аня:5" |
| **Ожидаемый результат** | {5=[Вася, Аня], 3=[Петя]} |

**Результат выполнения:**
```
Выберите вариант: 2
Введите количество записей: 3
--- Запись 1 ---
Имя: вася
Номер (оставьте пустым если нет номера): 5
--- Запись 2 ---
Имя: ПЕТЯ
Номер (оставьте пустым если нет номера): 3
--- Запись 3 ---
Имя: аня
Номер (оставьте пустым если нет номера): 5
=== РЕЗУЛЬТАТ ГРУППИРОВКИ ===
Сырой вывод: {3=[Петя], 5=[Вася, Аня]}
--- Форматированный вывод ---
Номер 3: [Петя]
Номер 5: [Вася, Аня]
```

## Сводная таблица результатов тестирования

| Задание | Количество тестов | Успешных тестов | Процент успеха | Примечания |
|---------|------------------|-----------------|----------------|------------|
| 1.1 Дроби с кэшированием | 3 | 3 | 100% | Все операции работают корректно |
| 2.1 Подсчет мяуканий | 2 | 2 | 100% | Decorator работает как ожидалось |
| 3.3 Вставка списков | 2 | 2 | 100% | Объединение и сортировка корректны |
| 4.3 Результаты соревнований | 2 | 2 | 100% | Определение лучших участников корректно |
| 5.7 Подсчет букв | 2 | 2 | 100% | Подсчет уникальных символов точен |
| 6.2 Построение очереди | 2 | 2 | 100% | Алгоритм построения очереди корректен |
| 7.1 Обработка точек | 1 | 1 | 100% | Stream API преобразует точки корректно |
| 7.2 Группировка имен | 2 | 2 | 100% | Группировка и нормализация работают |
