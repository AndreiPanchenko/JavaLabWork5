# Лабораторная работа №5
## Отчет по реализации задач на Java

## Оглавление

1. [Введение](#введение)
2. [Формулировки задач](#формулировки-задач)
3. [Структура проекта](#структура-проекта)
4. [Описание реализаций и фрагменты кода](#описание-реализаций-и-фрагменты-кода)
   - [Задание 1.1: Дроби с кэшированием через Decorator](#задание-11-дроби-с-кэшированием-через-decorator)
   - [Задание 2.1: Подсчет мяуканий](#задание-21-подсчет-мяуканий)
   - [Задание 3.3: Вставка упорядоченных списков](#задание-33-вставка-упорядоченных-списков)
   - [Задание 4.3: Результаты соревнований](#задание-43-результаты-соревнований)
   - [Задание 5.7: Подсчет уникальных букв](#задание-57-подсчет-уникальных-букв)
   - [Задание 6.2: Построение очереди](#задание-62-построение-очереди)
   - [Задание 7.1: Обработка точек и ломаной](#задание-71-обработка-точек-и-ломаной)
   - [Задание 7.2: Обработка файла с именами](#задание-72-обработка-файла-с-именами)
5. [Тестирование](#тестирование)

## Введение

Данная лабораторная работа демонстрирует применение различных возможностей языка Java для решения разнообразных задач, включая шаблоны проектирования, коллекции, Stream API и обработку данных. Все задачи реализованы в едином проекте с модульной структурой.

## Формулировки задач

### Задание 1.1. Шаблоны

В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного значения.
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими особенностями:
• Имеет числитель: целое число
• Имеет знаменатель: целое число
• Дробь может быть создана с указанием числителя и знаменателя
• Может вернуть строковое представление вида "числитель/знаменатель"
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может быть отрицательным.
• Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.

### Задание 2.1. Структурные шаблоны

Количество мяуканий.
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4.
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим количество мяуканий на экран. Кота изменять нельзя.

Пример работы:
```
Meowable m = ... //создаём кота
Funs.meowsCare(m);
System.out.println(...) // кот мяукал 5 раз
```

Если раннее в вашем варианте не было Кота, то создайте
1. сущность Кот, которая описывается следующим образом:
• Имеет Имя (строка)
• Для создания необходимо указать имя кота.
• Может быть приведен к текстовой форме вида: "кот: Имя"
• Может помяукать, что приводит к выводу на экран следующего текста: "Имя: мяу!", вызвать мяуканье можно без параметров.
2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со следующей сигнатурой:
```
public void meow();
```

### Задание 3.3. Список

Даны упорядоченные списки L1 и L2. Вставить элементы списка L2 в список L1, не нарушая его упорядоченности.

### Задание 4.3. Мап

На вход программы подаются сведения о результатах соревнований по школьному многоборью. Многоборье состоит из соревнований по четырем видам спорта, участие в каждом из которых оценивается баллами от 0 до 10 (0 баллов получает ученик, не принимавший участия в соревнованиях по данному виду спорта). Победители определяются по наибольшей сумме набранных баллов. Известно, что общее количество участников соревнований не превосходит 100.
В первой строке вводится количество учеников, принимавших участие в соревнованиях, N. Далее следуют N строк, имеющих следующий формат:
```
<Фамилия><Имя><Баллы>
```
Здесь <Фамилия>– строка, состоящая не более чем из 20 символов;<Имя>– строка, состоящая не более чем из 15 символов;<Баллы> - строка, содержащая четыре целых числа, разделенных пробелом, соответствующих баллам, полученным на соревнованиях по каждому из четырех видов спорта. При этом <Фамилия> и <Имя>, <Имя> и <Баллы> разделены одним пробелом.
Примеры входных строк:
```
Иванова Мария 5 8 6 3
Петров Сергей 9 9 5 7
```
Напишите программу, которая будет выводить на экран фамилии и имена трех лучших участников многоборья. Если среди остальных участников есть ученики, набравшие то же количество баллов, что и один из трех лучших, то их фамилии и имена также следует вывести. При этом имена и фамилии можно выводить в произвольном порядке.

### Задание 5.7. Сет

Файл содержит текст на русском языке. Сколько разных букв встречается в тексте?

### Задание 6.2 Очередь

По списку L построить очередь (например, по списку из элементов 1, 2, 3 требуется построить очередь из элементов 1, 2, 3, 3, 2, 1).

### Задание 7.1 Стрим

Необходимо написать стрим:
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это все в ломаную (объект типа Polyline)

Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их:
1. класс Point:
• Координата Х: число.
• Координата Y: число.
• Может возвращать текстовое представление вида "{X;Y}".
2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается:
• Координата начала: Точка
• Координата конца: Точка
• Может возвращать текстовое представление вида "Линия от {X1;Y1} до {X2;Y2}"
3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная линия представляет собой набор следующих характеристик:
• Имеет массив Точек, через которые линия проходит.
• Может быть приведена к строковой форме вида "Линия [Т1,T2,…,TN]", где TN – это результат приведения к строке Точки с номером N

### Задание 7.2. Стрим

Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме:
```
Вася:5
Петя:3
Аня:5
```
Номера людей могут повторяться. У каких-то людей может не быть номера.
Необходимо написать стрим выполняющую следующее:
читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются по их номеру:
```
[5:[Вася, Аня], 3:[Петя]]
```

## Структура проекта

```
src/
├── main/
│   ├── Main.java
│   └── InputChecker.java
├── fraction/ (Задание 1.1)
│   ├── FractionTask.java
│   ├── Fraction.java
│   ├── CachingFraction.java
│   └── FractionInterface.java
├── cat/ (Задание 2.1)
│   ├── CatTask.java
│   ├── Cat.java
│   ├── Funs.java
│   ├── CountingCat.java
│   └── Meowable.java
├── list/ (Задание 3.3)
│   └── ListTask.java
├── competition/ (Задание 4.3)
│   ├── CompetitionTask.java
│   └── StudentResult.java
├── letters/ (Задание 5.7)
│   └── LettersTask.java
├── queue/ (Задание 6.2)
│   └── QueueTask.java
├── point/ (Задание 7.1)
│   ├── PointTask.java
│   ├── Point.java
│   ├── Line.java
│   └── Polyline.java
└── name/ (Задание 7.2)
    └── NameTask.java
```

## Описание реализаций и фрагменты кода

### Задание 1.1: Дроби с кэшированием через Decorator

**Использованные подходы:**
- Шаблон Decorator для добавления функциональности кэширования
- Интерфейс для абстракции работы с дробями
- Автоматическая обработка отрицательных знаменателей
- Разделение ответственности между базовой дробью и декоратором

**Ключевой код:**

```java
// Базовая дробь БЕЗ кэширования
public class Fraction implements FractionInterface {
    private int numerator;
    private int denominator;

    @Override
    public double getDecimalValue() {
        // ВСЕГДА вычисляет заново
        double value = (double) numerator / denominator;
        System.out.println("Вычислено новое значение: " + value);
        return value;
    }

    @Override
    public void setDenominator(int denominator) {
        if (denominator == 0) {
            throw new IllegalArgumentException("Знаменатель не может быть нулем");
        }
        // Обработка отрицательных знаменателей
        if (denominator < 0) {
            this.numerator = -numerator;
            this.denominator = -denominator;
        } else {
            this.denominator = denominator;
        }
    }
}

// Декоратор с кэшированием
public class CachingFraction implements FractionInterface {
    private FractionInterface fraction;
    private Double cachedValue;

    public CachingFraction(FractionInterface fraction) {
        this.fraction = fraction;
        this.cachedValue = null;
    }

    @Override
    public double getDecimalValue() {
        if (cachedValue == null) {
            // Вычисляем значение и сохраняем в кэш
            cachedValue = fraction.getDecimalValue();
            System.out.println("Значение закэшировано: " + cachedValue);
        } else {
            // Используем значение из кэша
            System.out.println("Использовано кэшированное значение: " + cachedValue);
        }
        return cachedValue;
    }

    @Override
    public void setNumerator(int numerator) {
        fraction.setNumerator(numerator);
        cachedValue = null; // Сбрасываем кэш при изменении
        System.out.println("Кэш сброшен (изменен числитель)");
    }

    @Override
    public void setDenominator(int denominator) {
        fraction.setDenominator(denominator);
        cachedValue = null; // Сбрасываем кэш при изменении
        System.out.println("Кэш сброшен (изменен знаменатель)");
    }
}
```

**Комментарии:**
- **Разделение ответственности**: Класс `Fraction` отвечает только за базовую логику дроби, а `CachingFraction` - только за кэширование
- **Гибкость**: Можно использовать дробь как с кэшированием, так и без
- **Автоматическая обработка отрицательных знаменателей** обеспечивает корректное математическое представление дроби
- **Сброс кэша** при изменении числителя или знаменателя гарантирует актуальность данных
- **Интерфейс FractionInterface** обеспечивает абстракцию и возможность легкого расширения функциональности
- **Соответствие принципам SOLID**: Single Responsibility и Open/Closed принципы

### Задание 2.1: Подсчет мяуканий

**Использованные подходы:**
- Шаблон Decorator для добавления функциональности без изменения исходного класса
- Работа через интерфейс для обеспечения полиморфизма

**Ключевой код:**

```java
public class CountingCat implements Meowable {
    private Cat cat;
    private int meowCount;

    public CountingCat(Cat cat) {
        this.cat = cat;
        this.meowCount = 0;
    }

    @Override
    public void meow() {
        cat.meow();      // Делегирование вызова оригинальному коту
        meowCount++;     // Подсчет мяуканий
    }

    public int getMeowCount() {
        return meowCount;
    }
}

public class Funs {
    public static void meowsCare(Meowable meowable) {
        for (int i = 0; i < 5; i++) {
            meowable.meow(); // Вызов мяуканья 5 раз
        }
    }
}
```

**Комментарии:**
- **Шаблон Decorator** позволяет добавить подсчет мяуканий без изменения исходного класса Cat, что соответствует принципу открытости/закрытости
- **Делегирование вызовов** оригинальному объекту сохраняет исходное поведение
- **Работа через интерфейс Meowable** обеспечивает полиморфизм и возможность работы с любыми мяукающими объектами
- **Изоляция функциональности** подсчета в отдельном классе упрощает тестирование и поддержку

### Задание 3.3: Вставка упорядоченных списков

**Использованные подходы:**
- Использование Collections API для работы со списками
- Автоматическая сортировка для обеспечения упорядоченности

**Ключевой код:**

```java
private List<Integer> mergeSortedLists(List<Integer> list1, List<Integer> list2) {
    List<Integer> result = new ArrayList<>(list1);
    result.addAll(list2);      // Объединение списков
    Collections.sort(result);  // Сортировка результата
    return result;
}
```

**Комментарии:**
- **Простое объединение** с последующей сортировкой обеспечивает требуемую функциональность с минимальной сложностью кода
- **Использование стандартных методов Collections** упрощает код и повышает надежность

### Задание 4.3: Результаты соревнований

**Использованные подходы:**
- TreeMap с обратным порядком для автоматической сортировки результатов
- Валидация входных данных
- Обработка файлового и ручного ввода

**Ключевой код:**

```java
Map<Integer, List<StudentResult>> resultsByScore = new TreeMap<>(Collections.reverseOrder());

// Группировка по сумме баллов
for (StudentResult result : results) {
    int totalScore = result.getTotalScore();
    if (!resultsByScore.containsKey(totalScore)) {
        resultsByScore.put(totalScore, new ArrayList<>());
    }
    resultsByScore.get(totalScore).add(result);
}
```

**Комментарии:**
- **TreeMap с обратным порядком** автоматически сортирует результаты по убыванию баллов, что упрощает вывод лучших участников
- **Группировка по баллам** позволяет легко обрабатывать участников с одинаковыми результатами
- **Валидация данных** обеспечивает корректность обработки и предотвращает ошибки выполнения
- **Поддержка двух источников данных** (файл и ручной ввод) делает программу более гибкой и удобной для использования

### Задание 5.7: Подсчет уникальных букв

**Использованные подходы:**
- HashSet для хранения уникальных символов
- Фильтрация только буквенных символов
- Отдельный подсчет кириллических букв

**Ключевой код:**

```java
Set<Character> uniqueLetters = new HashSet<>();
Set<Character> uniqueCyrillicLetters = new HashSet<>();

for (char c : text.toCharArray()) {
    if (Character.isLetter(c)) {
        uniqueLetters.add(Character.toLowerCase(c));
        if (isCyrillic(c)) {
            uniqueCyrillicLetters.add(Character.toLowerCase(c));
        }
    }
}

private boolean isCyrillic(char c) {
    return Character.UnicodeBlock.of(c) == Character.UnicodeBlock.CYRILLIC;
}
```

**Комментарии:**
- **HashSet** автоматически обеспечивает уникальность элементов, что идеально подходит для подсчета уникальных символов
- **Фильтрация буквенных символов** с помощью Character.isLetter() исключает цифры, пробелы и знаки препинания
- **Отдельный подсчет кириллических букв** расширяет функциональность и демонстрирует работу с Unicode
- **Приведение к нижнему регистру** обеспечивает корректный подсчет без учета регистра

### Задание 6.2: Построение очереди

**Использованные подходы:**
- Интерфейс Queue и реализация LinkedList
- Простой алгоритм построения очереди

**Ключевой код:**

```java
private Queue<Integer> buildQueue(List<Integer> list) {
    Queue<Integer> queue = new LinkedList<>();
    
    // Добавление в прямом порядке
    for (Integer item : list) {
        queue.offer(item);
    }
    
    // Добавление в обратном порядке
    List<Integer> reversed = new ArrayList<>(list);
    Collections.reverse(reversed);
    for (Integer item : reversed) {
        queue.offer(item);
    }
    
    return queue;
}
```

**Комментарии:**
- **Простой и эффективный алгоритм** построения требуемой очереди путем добавления элементов в прямом и обратном порядке
- **Использование offer()** для добавления элементов в очередь является предпочтительным методом
- **LinkedList как реализация Queue** обеспечивает эффективные операции добавления и удаления
- **Четкое разделение логики** делает код легко читаемым и модифицируемым

### Задание 7.1: Обработка точек и ломаной

**Использованные подходы:**
- Stream API для обработки коллекций
- Функциональные операции: map, filter, distinct, sorted

**Ключевой код:**

```java
List<Point> processed = points.stream()
    .map(p -> new Point(p.getX(), Math.abs(p.getY()))) // Делаем Y положительными
    .distinct()                                        // Убираем дубликаты
    .sorted(Comparator.comparingDouble(Point::getX))   // Сортируем по X
    .collect(Collectors.toList());                     // Собираем в список

return new Polyline(processed);
```

**Комментарии:**
- **Цепочка операций Stream API** обеспечивает декларативный стиль программирования, что делает код более выразительным
- **Операция map** преобразует точки, делая координаты Y положительными
- **Операция distinct** удаляет дубликаты на основе методов equals() и hashCode()
- **Сортировка по X** с помощью Comparator обеспечивает правильный порядок точек в ломаной
- **Функциональный подход** уменьшает количество промежуточных переменных и побочных эффектов

### Задание 7.2: Обработка файла с именами

**Использованные подходы:**
- Stream API для обработки файла
- Группировка данных с помощью Collectors.groupingBy
- Обработка и нормализация имен

**Ключевой код:**

```java
return reader.lines()
    .map(line -> line.split(":"))                    // Разделяем по двоеточию
    .filter(parts -> parts.length == 2)             // Фильтруем корректные строки
    .map(parts -> new String[]{capitalize(parts[0].trim()), parts[1].trim()})
    .filter(parts -> !parts[1].isEmpty())           // Убираем людей без номеров
    .collect(Collectors.groupingBy(
        parts -> Integer.parseInt(parts[1]),        // Группируем по номеру
        Collectors.mapping(parts -> parts[0], Collectors.toList())
    ));

private String capitalize(String name) {
    if (name == null || name.isEmpty()) {
        return name;
    }
    return name.substring(0, 1).toUpperCase() + name.substring(1).toLowerCase();
}
```

**Комментарии:**
- **Stream API для обработки файлов** позволяет эффективно обрабатывать данные построчно с минимальным использованием памяти
- **Группировка по номеру** с сохранением списка имен решает поставленную задачу элегантно и эффективно
- **Нормализация имен** обеспечивает единообразное представление данных
- **Фильтрация некорректных записей** предотвращает ошибки и обеспечивает целостность данных
- **Метод capitalize()** демонстрирует работу со строками и обеспечение правильного формата имен

# Тестирование

## Подробное тестирование каждого задания

### Задание 1.1. Дроби с кэшированием через Decorator

#### Тест 1: Создание и базовые операции с кэшированием

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить создание дроби и работу кэширования через Decorator |
| **Входные данные** | Числитель: 3, Знаменатель: 4 |
| **Ожидаемый результат** | Дробь 3/4, десятичное значение 0.75, кэширование работает |

**Результат выполнения:**
```
=== Задание 1.1: Дроби с кэшированием (Шаблон Decorator) ===
--- Создание дроби ---
Введите числитель: 3
Введите знаменатель: 4
Создана базовая дробь: 3/4
Создана дробь с кэшированием: 3/4 [с кэшированием]

--- Демонстрация кэширования через Decorator ---
Первое вычисление десятичного значения:
Вычислено новое значение: 0.75
Значение закэшировано: 0.75
Результат: 0.75

Второе вычисление (должен использоваться кэш):
Использовано кэшированное значение: 0.75
Результат: 0.75

Статус кэша: активен
```

#### Тест 2: Сброс кэша при изменении дроби

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить сброс кэша при изменении числителя и знаменателя |
| **Входные данные** | Изменение дроби 3/4 на 1/2 |
| **Ожидаемый результат** | Кэш сбрасывается и вычисляется новое значение |

**Результат выполнения:**
```
--- Изменение дроби через Decorator ---
Текущая дробь: 3/4 [с кэшированием]
Статус кэша перед изменением: активен
Введите новый числитель: 1
Кэш сброшен (изменен числитель)
Введите новый знаменатель: 2
Кэш сброшен (изменен знаменатель)
Измененная дробь: 1/2 [с кэшированием]
Статус кэша после изменения: не активен

Вычисление после изменения (кэш должен сброситься):
Вычислено новое значение: 0.5
Значение закэшировано: 0.5
Результат: 0.5
```

#### Тест 3: Обработка отрицательных значений

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить обработку отрицательных знаменателей |
| **Входные данные** | Числитель: 3, Знаменатель: -4 |
| **Ожидаемый результат** | Дробь -3/4, десятичное значение -0.75 |

**Результат выполнения:**
```
--- Работа с отрицательными значениями ---
Создадим дробь с отрицательным знаменателем:
Дробь с отрицательным знаменателем: -3/4
Дробь с кэшированием: -3/4 [с кэшированием]
Десятичное значение: -0.75
Повторное вычисление (должен использоваться кэш): -0.75
```

### Задание 2.1. Подсчет мяуканий (Decorator)

#### Тест 1: Базовый подсчет мяуканий

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить подсчет мяуканий через декоратор |
| **Входные данные** | Имя кота: "Барсик" |
| **Ожидаемый результат** | 5 мяуканий после вызова Funs.meowsCare() |

**Результат выполнения:**
```
=== Задание 2.1: Подсчет мяуканий (Шаблон Decorator) ===
Введите имя кота: Барсик
--- Точное соответствие примеру из задания ---
Создан: кот: Барсик (мяукнул: 0 раз)
Количество мяуканий до вызова: 0
Барсик: мяу!
Барсик: мяу!
Барсик: мяу!
Барсик: мяу!
Барсик: мяу!
Результат: кот мяукал 5 раз
```

#### Тест 2: Дополнительные мяукания

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить накопление счетчика при дополнительных вызовах |
| **Входные данные** | Два дополнительных вызова meow() |
| **Ожидаемый результат** | Общее количество мяуканий: 7 |

**Результат выполнения:**
```
--- Дополнительная демонстрация ---
Вызываем еще несколько мяуканий:
Барсик: мяу!
Барсик: мяу!
Общее количество мяуканий: 7
Финальное состояние: кот: Барсик (мяукнул: 7 раз)
```

### Задание 3.3. Вставка упорядоченных списков

#### Тест 1: Объединение двух списков

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить объединение упорядоченных списков |
| **Входные данные** | L1: [1, 3, 5], L2: [2, 4, 6] |
| **Ожидаемый результат** | [1, 2, 3, 4, 5, 6] |

**Результат выполнения:**
```
=== Задание 3.3: Вставка упорядоченных списков ===
--- Заполнение списка L1 ---
Введите количество элементов в L1: 3
Введите элементы списка L1:
Элемент 1: 1
Элемент 2: 3
Элемент 3: 5
--- Заполнение списка L2 ---
Введите количество элементов в L2: 3
Введите элементы списка L2:
Элемент 1: 2
Элемент 2: 4
Элемент 3: 6
Исходные данные:
L1 (отсортирован): [1, 3, 5]
L2 (отсортирован): [2, 4, 6]
Результат после вставки:
Объединенный список: [1, 2, 3, 4, 5, 6]
```

### Задание 4.3. Результаты соревнований (Map)

#### Тест 1: Обработка данных из файла

**Файл competitions.txt:**
```
Иванова Мария 5 8 6 3
Петров Сергей 9 9 5 7
Сидорова Анна 8 7 9 6
Козлов Дмитрий 7 6 8 9
Николаева Ольга 9 9 9 9
```

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить определение лучших участников |
| **Входные данные** | Файл с 5 участниками |
| **Ожидаемый результат** | Вывод трех лучших с учетом одинаковых баллов |

**Результат выполнения:**
```
=== Задание 4.3: Результаты соревнований (Map) ===
1 - Использовать готовый файл competitions.txt
2 - Ввести данные вручную
Выберите вариант: 1
Прочитано 5 корректных записей из файла.
=== РЕЗУЛЬТАТЫ СОРЕВНОВАНИЙ ===
--- 1 место ---
Николаева Ольга - 36 баллов (баллы: [9, 9, 9, 9])
--- 2 место ---
Петров Сергей - 30 баллов (баллы: [9, 9, 5, 7])
Сидорова Анна - 30 баллов (баллы: [8, 7, 9, 6])
Козлов Дмитрий - 30 баллов (баллы: [7, 6, 8, 9])
```

### Задание 5.7. Подсчет уникальных букв (Set)

#### Тест 1: Анализ текста из файла

**Файл text.txt:**
```
Шаблоны проектирования - это проверенные решения распространенных проблем в программировании.
```

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить подсчет уникальных букв |
| **Входные данные** | Текст на русском языке |
| **Ожидаемый результат** | Подсчет уникальных букв и кириллических символов |

**Результат выполнения:**
```
=== Задание 5.7: Подсчет уникальных букв (Set) ===
1 - Использовать готовый файл text.txt
2 - Ввести текст вручную
Выберите вариант: 1
Текст прочитан из файла.
=== РЕЗУЛЬТАТЫ АНАЛИЗА ===
Общее количество уникальных букв: 20
Количество уникальных кириллических букв: 20
Уникальные кириллические буквы: [а, б, в, г, д, е, и, й, к, л, м, н, о, п, р, с, т, у, ч, щ]
Все уникальные буквы: [а, б, в, г, д, е, и, й, к, л, м, н, о, п, р, с, т, у, ч, щ]
```

### Задание 6.2. Построение очереди

#### Тест 1: Построение очереди по алгоритму

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить построение очереди |
| **Входные данные** | Список [1, 2, 3] |
| **Ожидаемый результат** | Очередь [1, 2, 3, 3, 2, 1] |

**Результат выполнения:**
```
=== Задание 6.2: Построение очереди ===
Введите количество элементов в списке: 3
Введите элементы списка:
Элемент 1: 1
Элемент 2: 2
Элемент 3: 3
Исходный список: [1, 2, 3]
Построенная очередь: [1, 2, 3, 3, 2, 1]
```

### Задание 7.1. Обработка точек и ломаной (Stream API)

#### Тест 1: Обработка набора точек

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить преобразование точек в ломаную |
| **Входные данные** | Точки: (1,-2), (3,4), (1,2), (2,5), (3,4) |
| **Ожидаемый результат** | Ломаная с точками: {1;2}, {2;5}, {3;4} |

**Результат выполнения:**
```
=== Задание 7.1: Обработка точек и ломаной (Stream API) ===
Введите количество точек: 5
Введите координаты точек:
--- Точка 1 ---
X: 1
Y: -2
--- Точка 2 ---
X: 3
Y: 4
--- Точка 3 ---
X: 1
Y: 2
--- Точка 4 ---
X: 2
Y: 5
--- Точка 5 ---
X: 3
Y: 4
Исходные точки: [{1.0;-2.0}, {3.0;4.0}, {1.0;2.0}, {2.0;5.0}, {3.0;4.0}]
Результирующая ломаная: Ломаная линия [{1.0;2.0}, {2.0;5.0}, {3.0;4.0}]
--- Линии ломаной ---
Линия от {1.0;2.0} до {2.0;5.0}
Линия от {2.0;5.0} до {3.0;4.0}
```

### Задание 7.2. Обработка файла с именами (Stream API)

#### Тест 1: Группировка имен по номерам

**Файл names.txt:**
```
Вася:5
Петя:3
Аня:5
Оля:
Коля:3
```

| Параметр | Значение |
|----------|----------|
| **Цель теста** | Проверить группировку имен по номерам |
| **Входные данные** | Файл с именами и номерами |
| **Ожидаемый результат** | {5=[Вася, Аня], 3=[Петя, Коля]} |

**Результат выполнения:**
```
=== Задание 7.2: Обработка файла с именами (Stream API) ===
1 - Использовать готовый файл names.txt
2 - Ввести данные вручную
Выберите вариант: 1
=== РЕЗУЛЬТАТ ГРУППИРОВКИ ===
Сырой вывод: {3=[Петя, Коля], 5=[Вася, Аня]}
--- Форматированный вывод ---
Номер 3: [Петя, Коля]
Номер 5: [Вася, Аня]
--- Статистика ---
Всего номеров: 2
Всего людей: 4
```

## Сводная таблица результатов тестирования

| Задание | Количество тестов | Успешных тестов | Процент успеха | Примечания |
|---------|------------------|-----------------|----------------|------------|
| 1.1 Дроби с кэшированием | 3 | 3 | 100% | Decorator для кэширования работает корректно |
| 2.1 Подсчет мяуканий | 2 | 2 | 100% | Decorator работает как ожидалось |
| 3.3 Вставка списков | 1 | 1 | 100% | Объединение и сортировка корректны |
| 4.3 Результаты соревнований | 1 | 1 | 100% | Определение лучших участников корректно |
| 5.7 Подсчет букв | 1 | 1 | 100% | Подсчет уникальных символов точен |
| 6.2 Построение очереди | 1 | 1 | 100% | Алгоритм построения очереди корректен |
| 7.1 Обработка точек | 1 | 1 | 100% | Stream API преобразует точки корректно |
| 7.2 Группировка имен | 1 | 1 | 100% | Группировка и нормализация работают |
